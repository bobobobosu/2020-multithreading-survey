{"version":3,"file":"main.mjs","sources":["../../output/transfer/TransferrableMutation.js","../../output/main-thread/nodes.js","../../output/main-thread/commands/event-subscription.js","../../output/main-thread/deserializeTransferrableObject.js","../../output/main-thread/commands/function.js","../../output/main-thread/strings.js","../../output/main-thread/serialize.js","../../output/main-thread/debugging.js","../../output/main-thread/object-context.js","../../output/main-thread/exported-worker.js","../../output/main-thread/install.js"],"sourcesContent":["/**\n * Returns true if the mutation type can cause a user-visible change to the DOM.\n * @param type\n */\nexport const isUserVisibleMutation = (type) => {\n    switch (type) {\n        case 4 /* EVENT_SUBSCRIPTION */:\n        case 5 /* GET_BOUNDING_CLIENT_RECT */:\n        case 6 /* LONG_TASK_START */:\n        case 7 /* LONG_TASK_END */:\n        case 12 /* STORAGE */:\n        case 8 /* OFFSCREEN_CANVAS_INSTANCE */:\n        case 13 /* FUNCTION_CALL */:\n            return false;\n        default:\n            return true;\n    }\n};\nexport const DefaultAllowedMutations = [\n    0 /* ATTRIBUTES */,\n    1 /* CHARACTER_DATA */,\n    2 /* CHILD_LIST */,\n    3 /* PROPERTIES */,\n    4 /* EVENT_SUBSCRIPTION */,\n    5 /* GET_BOUNDING_CLIENT_RECT */,\n    6 /* LONG_TASK_START */,\n    7 /* LONG_TASK_END */,\n    8 /* OFFSCREEN_CANVAS_INSTANCE */,\n    9 /* OBJECT_MUTATION */,\n    10 /* OBJECT_CREATION */,\n    11 /* IMAGE_BITMAP_INSTANCE */,\n    12 /* STORAGE */,\n    13 /* FUNCTION_CALL */,\n    14 /* SCROLL_INTO_VIEW */,\n];\nexport const ReadableMutationType = {\n    0: 'ATTRIBUTES',\n    1: 'CHARACTER_DATA',\n    2: 'CHILD_LIST',\n    3: 'PROPERTIES',\n    4: 'EVENT_SUBSCRIPTION',\n    5: 'GET_BOUNDING_CLIENT_RECT',\n    6: 'LONG_TASK_START',\n    7: 'LONG_TASK_END',\n    8: 'OFFSCREEN_CANVAS_INSTANCE',\n    9: 'OBJECT_MUTATION',\n    10: 'OBJECT_CREATION',\n    11: 'IMAGE_BITMAP_INSTANCE',\n    12: 'STORAGE',\n    13: 'FUNCTION_INVOCATION',\n    14: 'SCROLL_INTO_VIEW',\n};\n//# sourceMappingURL=TransferrableMutation.js.map","/**\n * IE11 doesn't support NodeList.prototype.forEach\n * https://developer.mozilla.org/en-US/docs/Web/API/NodeList/forEach\n * @param list NodeList to iterate over\n * @param callback method to call with each node\n */\nconst nodeListEach = (list, callback) => Array.prototype.forEach.call(list, callback);\nexport const BASE_ELEMENT_INDEX = 1;\nexport class NodeContext {\n    baseElement;\n    stringContext;\n    count;\n    nodes;\n    /**\n     * Called when initializing a Worker, ensures the nodes in baseElement are\n     * known for transmission into the Worker and future mutation events from the\n     * Worker.\n     * @param baseElement Element that will be controlled by a Worker\n     */\n    constructor(stringContext, baseElement) {\n        this.count = 2;\n        this.stringContext = stringContext;\n        // The nodes map is populated with two default values pointing to baseElement.\n        // These are [document, document.body] from the worker.\n        this.nodes = new Map([\n            [BASE_ELEMENT_INDEX, baseElement],\n            [2, baseElement],\n        ]);\n        this.baseElement = baseElement;\n        // To ensure a lookup works correctly from baseElement\n        // add an index equal to the background thread document.body.\n        baseElement._index_ = 2;\n        // Lastly, it's important while initializing the document that we store\n        // the default nodes present in the server rendered document.\n        nodeListEach(baseElement.childNodes, (n) => this.storeNodes(n));\n    }\n    createNodes = (buffer, sanitizer) => {\n        const nodeBuffer = new Uint16Array(buffer);\n        const nodeBufferLength = nodeBuffer.length;\n        for (let iterator = 0; iterator < nodeBufferLength; iterator += 5 /* End */) {\n            let node;\n            if (nodeBuffer[iterator + 1 /* NodeType */] === 3 /* TEXT_NODE */) {\n                node = document.createTextNode(this.stringContext.get(nodeBuffer[iterator + 3 /* TextContent */]));\n            }\n            else if (nodeBuffer[iterator + 1 /* NodeType */] === 8 /* COMMENT_NODE */) {\n                node = document.createComment(this.stringContext.get(nodeBuffer[iterator + 3 /* TextContent */]));\n            }\n            else if (nodeBuffer[iterator + 1 /* NodeType */] === 11 /* DOCUMENT_FRAGMENT_NODE */) {\n                node = document.createDocumentFragment();\n            }\n            else {\n                const nodeName = this.stringContext.get(nodeBuffer[iterator + 2 /* NodeName */]);\n                node =\n                    nodeBuffer[iterator + 4 /* Namespace */] !== 0\n                        ? document.createElementNS(this.stringContext.get(nodeBuffer[iterator + 4 /* Namespace */]), nodeName)\n                        : document.createElement(nodeName);\n                // TODO(KB): Restore Properties\n                // skeleton.properties.forEach(property => {\n                //   node[`${property.name}`] = property.value;\n                // });\n                // ((skeleton as TransferrableElement)[TransferrableKeys.childNodes] || []).forEach(childNode => {\n                //   if (childNode[TransferrableKeys.transferred] === NumericBoolean.FALSE) {\n                //     node.appendChild(this.createNode(childNode as TransferrableNode));\n                //   }\n                // });\n                // If `node` is removed by the sanitizer, don't store it and return null.\n                if (sanitizer && !sanitizer.sanitize(node)) {\n                    continue;\n                }\n            }\n            this.storeNode(node, nodeBuffer[iterator]);\n        }\n    };\n    /**\n     * Returns the real DOM Element corresponding to a serialized Element object.\n     * @param id\n     * @return RenderableElement | null\n     */\n    getNode = (id) => {\n        const node = this.nodes.get(id);\n        if (node && node.nodeName === 'BODY') {\n            // If the node requested is the \"BODY\"\n            // Then we return the base node this specific <amp-script> comes from.\n            // This encapsulates each <amp-script> node.\n            return this.baseElement;\n        }\n        return node;\n    };\n    /**\n     * Store the requested node and all of its children.\n     * @param node node to store.\n     */\n    storeNodes = (node) => {\n        this.storeNode(node, ++this.count);\n        nodeListEach(node.childNodes, (n) => this.storeNodes(n));\n    };\n    /**\n     * Establish link between DOM `node` and worker-generated identifier `id`.\n     *\n     * These _shouldn't_ collide between instances of <amp-script> since\n     * each element creates it's own pool on both sides of the worker\n     * communication bridge.\n     * @param node\n     * @param id\n     */\n    storeNode(node, id) {\n        node._index_ = id;\n        this.nodes.set(id, node);\n    }\n}\n//# sourceMappingURL=nodes.js.map","import { ADD_EVENT_SUBSCRIPTION_LENGTH, REMOVE_EVENT_SUBSCRIPTION_LENGTH, } from '../../transfer/TransferrableEvent';\nimport { BASE_ELEMENT_INDEX } from '../nodes';\n/**\n * Monitoring Nodes attribute changes requires a Mutation Observer.\n * We store the nodes being monitored to avoid creating more than one Observer\n * per Element.\n */\nconst monitoredNodes = new Map();\n/**\n * Instead of a whitelist of elements that need their value tracked, use the existence\n * of a property called value to drive the decision.\n * @param node node to check if values should be tracked.\n * @return boolean if the node should have its value property tracked.\n */\nconst shouldTrackChanges = (node) => node && 'value' in node;\n/**\n * When a node that has a value needing synced doesn't already have an event listener\n * listening for input values, ensure the value is synced with a default listener.\n * @param worker whom to dispatch value toward.\n * @param node node to listen to value changes on.\n */\nexport const applyDefaultInputListener = (workerContext, node) => {\n    if (shouldTrackChanges(node) && node.oninput === null) {\n        node.oninput = () => fireValueChange(workerContext, node);\n    }\n};\n/**\n * Use a MutationObserver to capture value changes based on Attribute modification (frequently used by frameworks).\n * @param worker whom to dispatch value toward.\n * @param node node to listen to value changes on.\n */\nexport const sendValueChangeOnAttributeMutation = (workerContext, node) => {\n    if (shouldTrackChanges(node) && !monitoredNodes.get(node)) {\n        new MutationObserver((mutations) => mutations.map((mutation) => fireValueChange(workerContext, mutation.target))).observe(node, { attributes: true });\n        monitoredNodes.set(node, true);\n    }\n};\n/**\n * Tell WorkerDOM what the value is for a Node.\n * @param worker whom to dispatch value toward.\n * @param node where to get the value from.\n */\nconst fireValueChange = (workerContext, node) => workerContext.messageToWorker({\n    [12 /* type */]: 4 /* SYNC */,\n    [40 /* sync */]: {\n        [7 /* index */]: node._index_,\n        [21 /* value */]: node.value,\n    },\n});\n/**\n * Tell WorkerDOM what the window dimensions are.\n * @param workerContext\n * @param cachedWindowSize\n */\nconst fireResizeChange = (workerContext, cachedWindowSize) => workerContext.messageToWorker({\n    [12 /* type */]: 5 /* RESIZE */,\n    [40 /* sync */]: cachedWindowSize,\n});\n/**\n * Convert a TouchList into a TransferrableTouchList\n * @param touchList\n */\nconst createTransferrableTouchList = (touchList) => Object.values(touchList).map((touch) => [\n    touch.identifier,\n    touch.screenX,\n    touch.screenY,\n    touch.clientX,\n    touch.clientY,\n    touch.pageX,\n    touch.pageY,\n    touch.target._index_,\n]);\nexport const EventSubscriptionProcessor = (strings, nodeContext, workerContext, objectContext, config) => {\n    const knownListeners = [];\n    const allowedExecution = config.executorsAllowed.includes(4 /* EVENT_SUBSCRIPTION */);\n    let cachedWindowSize = [window.innerWidth, window.innerHeight];\n    /**\n     * Register an event handler for dispatching events to worker thread\n     * @param worker whom to dispatch events toward\n     * @param index node index the event comes from (used to dispatchEvent in worker thread).\n     * @return eventHandler function consuming event and dispatching to worker thread\n     */\n    const eventHandler = (index, preventDefault) => (event) => {\n        if (preventDefault) {\n            event.preventDefault();\n        }\n        if (shouldTrackChanges(event.currentTarget)) {\n            fireValueChange(workerContext, event.currentTarget);\n        }\n        else if (event.type === 'resize') {\n            const { innerWidth, innerHeight } = window;\n            if (cachedWindowSize[0] === innerWidth && cachedWindowSize[1] === innerHeight) {\n                return;\n            }\n            cachedWindowSize = [window.innerWidth, window.innerHeight];\n            fireResizeChange(workerContext, cachedWindowSize);\n        }\n        workerContext.messageToWorker({\n            [12 /* type */]: 1 /* EVENT */,\n            [39 /* event */]: {\n                [7 /* index */]: index,\n                [25 /* bubbles */]: event.bubbles,\n                [26 /* cancelable */]: event.cancelable,\n                [27 /* cancelBubble */]: event.cancelBubble,\n                [28 /* currentTarget */]: [event.currentTarget._index_ || 0],\n                [29 /* defaultPrevented */]: event.defaultPrevented,\n                [30 /* eventPhase */]: event.eventPhase,\n                [31 /* isTrusted */]: event.isTrusted,\n                [32 /* returnValue */]: event.returnValue,\n                [13 /* target */]: [event.target._index_ || 0],\n                [33 /* timeStamp */]: event.timeStamp,\n                [12 /* type */]: event.type,\n                [35 /* keyCode */]: 'keyCode' in event ? event.keyCode : undefined,\n                [60 /* pageX */]: 'pageX' in event ? event.pageX : undefined,\n                [61 /* pageY */]: 'pageY' in event ? event.pageY : undefined,\n                [65 /* offsetX */]: 'offsetX' in event ? event.offsetX : undefined,\n                [66 /* offsetY */]: 'offsetY' in event ? event.offsetY : undefined,\n                [62 /* touches */]: 'touches' in event ? createTransferrableTouchList(event.touches) : undefined,\n                [63 /* changedTouches */]: 'changedTouches' in event ? createTransferrableTouchList(event.changedTouches) : undefined,\n            },\n        });\n    };\n    /**\n     * If the worker requests to add an event listener to 'change' for something the foreground thread is already listening to,\n     * ensure that only a single 'change' event is attached to prevent sending values multiple times.\n     * @param target node to change listeners on\n     * @param addEvent is this an 'addEvent' or 'removeEvent' change\n     * @param mutations Uint16Array for this set of changes\n     * @param iterator current location in array to perform this change on\n     */\n    const processListenerChange = (target, addEvent, mutations, iterator) => {\n        const type = strings.get(mutations[iterator]);\n        const eventIndex = mutations[iterator + 1 /* Index */];\n        if (target === nodeContext.baseElement) {\n            if (addEvent) {\n                const preventDefault = Boolean(mutations[iterator + 5 /* WorkerDOMPreventDefault */]);\n                addEventListener(type, (knownListeners[eventIndex] = eventHandler(BASE_ELEMENT_INDEX, preventDefault)));\n            }\n            else {\n                removeEventListener(type, knownListeners[eventIndex]);\n            }\n            return;\n        }\n        let inputEventSubscribed = target.oninput !== null;\n        const isChangeEvent = type === 'change';\n        if (addEvent) {\n            if (isChangeEvent) {\n                inputEventSubscribed = true;\n                target.onchange = null;\n            }\n            const preventDefault = Boolean(mutations[iterator + 5 /* WorkerDOMPreventDefault */]);\n            target.addEventListener(type, (knownListeners[eventIndex] = eventHandler(target._index_, preventDefault)));\n        }\n        else {\n            if (isChangeEvent) {\n                inputEventSubscribed = false;\n            }\n            target.removeEventListener(type, knownListeners[eventIndex]);\n        }\n        if (shouldTrackChanges(target)) {\n            if (!inputEventSubscribed)\n                applyDefaultInputListener(workerContext, target);\n            sendValueChangeOnAttributeMutation(workerContext, target);\n        }\n    };\n    return {\n        execute(mutations, startPosition, allowedMutation) {\n            const addEventListenerCount = mutations[startPosition + 3 /* AddEventListenerCount */];\n            const removeEventListenerCount = mutations[startPosition + 2 /* RemoveEventListenerCount */];\n            const addEventListenersPosition = startPosition + 4 /* Events */ + removeEventListenerCount * REMOVE_EVENT_SUBSCRIPTION_LENGTH;\n            const endPosition = startPosition +\n                4 /* Events */ +\n                addEventListenerCount * ADD_EVENT_SUBSCRIPTION_LENGTH +\n                removeEventListenerCount * REMOVE_EVENT_SUBSCRIPTION_LENGTH;\n            if (allowedExecution && allowedMutation) {\n                const targetIndex = mutations[startPosition + 1 /* Target */];\n                const target = nodeContext.getNode(targetIndex);\n                if (target) {\n                    let iterator = startPosition + 4 /* Events */;\n                    while (iterator < endPosition) {\n                        const isRemoveEvent = iterator <= addEventListenersPosition;\n                        processListenerChange(target, isRemoveEvent, mutations, iterator);\n                        iterator += isRemoveEvent ? REMOVE_EVENT_SUBSCRIPTION_LENGTH : ADD_EVENT_SUBSCRIPTION_LENGTH;\n                    }\n                }\n                else {\n                    console.error(`getNode(${targetIndex}) is null.`);\n                }\n            }\n            return endPosition;\n        },\n        print(mutations, startPosition) {\n            const addEventListenerCount = mutations[startPosition + 3 /* AddEventListenerCount */];\n            const removeEventListenerCount = mutations[startPosition + 2 /* RemoveEventListenerCount */];\n            const addEventListenersPosition = startPosition + 4 /* Events */ + removeEventListenerCount * REMOVE_EVENT_SUBSCRIPTION_LENGTH;\n            const endPosition = startPosition +\n                4 /* Events */ +\n                addEventListenerCount * ADD_EVENT_SUBSCRIPTION_LENGTH +\n                removeEventListenerCount * REMOVE_EVENT_SUBSCRIPTION_LENGTH;\n            const targetIndex = mutations[startPosition + 1 /* Target */];\n            const target = nodeContext.getNode(targetIndex);\n            const removedEventListeners = [];\n            const addedEventListeners = [];\n            let iterator = startPosition + 4 /* Events */;\n            while (iterator < endPosition) {\n                const isRemoveEvent = iterator <= addEventListenersPosition;\n                const eventList = isRemoveEvent ? addedEventListeners : removedEventListeners;\n                eventList.push({\n                    type: strings.get(mutations[iterator]),\n                    index: mutations[iterator + 1],\n                });\n                iterator += isRemoveEvent ? REMOVE_EVENT_SUBSCRIPTION_LENGTH : ADD_EVENT_SUBSCRIPTION_LENGTH;\n            }\n            return {\n                target,\n                allowedExecution,\n                removedEventListeners,\n                addedEventListeners,\n            };\n        },\n    };\n};\n//# sourceMappingURL=event-subscription.js.map","const f32 = new Float32Array(1);\nconst u16 = new Uint16Array(f32.buffer);\n/**\n * Deserializes TransferrableObjectType arguments.\n * @param buffer Contains mutation with arguments to deserialize.\n * @param offset Start position of arguments in mutations buffer.\n * @param count Number of arguments to deserialize.\n * @param stringContext Strings context.\n * @param nodeContext Nodes context.\n * @param objectContext Objects context\n */\nexport function deserializeTransferrableObject(buffer, offset, count, stringContext, nodeContext, objectContext) {\n    const args = [];\n    for (let i = 0; i < count; i++) {\n        switch (buffer[offset++]) {\n            case 1 /* SmallInt */:\n                args.push(buffer[offset++]);\n                break;\n            case 2 /* Float */:\n                u16[0] = buffer[offset++];\n                u16[1] = buffer[offset++];\n                args.push(f32[0]);\n                break;\n            case 3 /* String */:\n                args.push(stringContext.get(buffer[offset++]));\n                break;\n            case 4 /* Array */:\n                const size = buffer[offset++];\n                const des = deserializeTransferrableObject(buffer, offset, size, stringContext, nodeContext, objectContext);\n                args.push(des.args);\n                offset = des.offset;\n                break;\n            case 5 /* TransferObject */:\n                if (!objectContext) {\n                    throw new Error('objectContext not provided.');\n                }\n                args.push(objectContext.get(buffer[offset++]));\n                break;\n            case 6 /* CanvasRenderingContext2D */:\n                const canvas = nodeContext.getNode(buffer[offset++]);\n                args.push(canvas.getContext('2d'));\n                break;\n            case 7 /* HTMLElement */:\n                args.push(nodeContext.getNode(buffer[offset++]));\n                break;\n            default:\n                throw new Error('Cannot deserialize argument.');\n        }\n    }\n    return {\n        args,\n        offset,\n    };\n}\n//# sourceMappingURL=deserializeTransferrableObject.js.map","let fnCallCount = 0;\n/**\n * A mapping between each request to callFunction and its Promise.\n */\nconst promiseMap = {};\n/**\n * Each invocation of `ExportedWorker.prototype.callFunction` needs to be registered with a unique index\n * and promise. The index is given to the underlying Worker and returned by it as well. That enables the main-thread to\n * correlate postMessage responses with their original requests and resolve/reject the correct Promise.\n */\nexport function registerPromise() {\n    // TS won't realize that the constructor promise assigns the handlers, so we `any` them.\n    let resolve;\n    let reject;\n    const promise = new Promise((res, rej) => {\n        resolve = res;\n        reject = rej;\n    });\n    // Wraparound to 0 in case someone attempts to register over 9 quadrillion promises.\n    if (fnCallCount >= Number.MAX_VALUE) {\n        fnCallCount = 0;\n    }\n    const index = fnCallCount++;\n    promiseMap[index] = { promise, resolve, reject };\n    return { promise, index };\n}\nexport const FunctionProcessor = (strings, nodeContext, workerContext, objectContext, config) => {\n    const allowedExecution = config.executorsAllowed.includes(13 /* FUNCTION_CALL */);\n    return {\n        execute(mutations, startPosition) {\n            if (allowedExecution) {\n                const status = mutations[startPosition + 1 /* Status */];\n                const index = mutations[startPosition + 2 /* Index */];\n                const value = mutations[startPosition + 3 /* Value */];\n                const parsed = strings.hasIndex(value) ? JSON.parse(strings.get(value)) : undefined;\n                if (status === 1 /* RESOLVE */) {\n                    promiseMap[index].resolve(parsed);\n                }\n                else {\n                    promiseMap[index].reject(parsed);\n                }\n                delete promiseMap[index];\n            }\n            return startPosition + 4 /* End */;\n        },\n        print(mutations, startPosition) {\n            const status = mutations[startPosition + 1 /* Status */];\n            const index = mutations[startPosition + 2 /* Index */];\n            const value = mutations[startPosition + 3 /* Value */];\n            return {\n                type: 'FUNCTION_INVOCATION',\n                status,\n                index,\n                value: strings.get(value),\n                allowedExecution,\n            };\n        },\n    };\n};\n//# sourceMappingURL=function.js.map","/**\n * Stores indexed strings that are used in postMessage() calls from the worker.\n */\nexport class StringContext {\n    strings;\n    constructor() {\n        this.strings = [];\n    }\n    /**\n     * Return a string for the specified index.\n     * @param index string index to retrieve.\n     * @return string in map for the index.\n     */\n    get(index) {\n        return this.strings[index] || '';\n    }\n    hasIndex(index) {\n        return this.strings[index] !== undefined;\n    }\n    /**\n     * Stores a string in mapping and returns the index of the location.\n     * @param value string to store\n     * @return location in map\n     */\n    store(value) {\n        this.strings.push(value);\n    }\n    /**\n     * Stores a set of strings.\n     * @param values\n     */\n    storeValues(values) {\n        values.forEach((v) => this.store(v));\n    }\n}\n//# sourceMappingURL=strings.js.map","import { applyDefaultInputListener, sendValueChangeOnAttributeMutation } from './commands/event-subscription';\nconst NODES_ALLOWED_TO_TRANSMIT_TEXT_CONTENT = [8 /* COMMENT_NODE */, 3 /* TEXT_NODE */];\n/**\n * Serializes a DOM element for transport to the worker.\n * @param element\n * @param minimizeString Function for minimizing strings for optimized ferrying across postMessage.\n */\nfunction createHydrateableNode(element, minimizeString, hydrateFilter, workerContext) {\n    const filteredChildNodes = [].slice.call(element.childNodes).filter(hydrateFilter);\n    const hydrated = {\n        [7 /* index */]: element._index_,\n        [11 /* transferred */]: 0 /* FALSE */,\n        [0 /* nodeType */]: element.nodeType,\n        [1 /* localOrNodeName */]: minimizeString(element.localName || element.nodeName),\n        [4 /* childNodes */]: filteredChildNodes.map((child) => createHydrateableNode(child, minimizeString, hydrateFilter, workerContext)),\n        [2 /* attributes */]: [].map.call(element.attributes || [], (attribute) => [\n            minimizeString(attribute.namespaceURI || 'null'),\n            minimizeString(attribute.name),\n            minimizeString(attribute.value),\n        ]),\n    };\n    if (element.namespaceURI != null) {\n        hydrated[6 /* namespaceURI */] = minimizeString(element.namespaceURI);\n    }\n    if (NODES_ALLOWED_TO_TRANSMIT_TEXT_CONTENT.includes(element.nodeType) && element.textContent !== null) {\n        hydrated[5 /* textContent */] = minimizeString(element.textContent);\n    }\n    applyDefaultInputListener(workerContext, element);\n    sendValueChangeOnAttributeMutation(workerContext, element);\n    return hydrated;\n}\n/**\n * @param element\n */\nexport function createHydrateableRootNode(element, config, workerContext) {\n    const hydrateFilter = config.hydrateFilter || (() => true);\n    const strings = [];\n    const stringMap = new Map();\n    const storeString = (value) => {\n        if (stringMap.has(value)) {\n            // Safe to cast since we verified the mapping contains the value.\n            return stringMap.get(value);\n        }\n        const count = strings.length;\n        stringMap.set(value, count);\n        strings.push(value);\n        return count;\n    };\n    const skeleton = createHydrateableNode(element, storeString, hydrateFilter, workerContext);\n    return { skeleton, strings };\n}\n/**\n * @param element\n */\nexport function createReadableHydrateableRootNode(element, config, workerContext) {\n    // \"Readable\" variant doesn't do any string minimization so we can output it for debugging purposes.\n    // Note that this intentionally breaks the type contract of createHydrateableNode() and HydrateableNode.\n    return createHydrateableNode(element, ((value) => value), config.hydrateFilter || (() => true), workerContext);\n}\n//# sourceMappingURL=serialize.js.map","/**\n * @fileoverview Converts index-based worker messages to human-readable objects.\n *\n * Requires manual upkeep to keep consistency with messages and enums.\n * This allows us to continue using 'const enum' for enum inlining.\n * @see https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md#9.4\n */\nimport { createReadableHydrateableRootNode } from './serialize';\n/**\n * @param element\n */\nexport const readableHydrateableRootNode = (element, config, workerContext) => readableHydrateableNode(createReadableHydrateableRootNode(element, config, workerContext));\n/**\n * @param nodeContext {NodeContext}\n * @param node {TransferredNode}\n */\nexport const readableTransferredNode = (nodeContext, node) => (node != null && nodeContext.getNode(node[0 /* Index */])) || node;\n/**\n * @param node\n */\nfunction readableHydrateableNode(node) {\n    const out = {\n        nodeType: node[0 /* nodeType */],\n        name: node[1 /* localOrNodeName */],\n        attributes: null,\n        childNodes: null,\n    };\n    const attributes = node[2 /* attributes */];\n    if (attributes) {\n        out.attributes = attributes.map((attr) => ({\n            name: attr[1],\n            value: attr[2],\n        }));\n    }\n    const childNodes = node[4 /* childNodes */];\n    if (childNodes) {\n        out.childNodes = childNodes.map(readableHydrateableNode);\n    }\n    return out;\n}\n/**\n * @param message {MessageToWorker}\n */\nconst isEvent = (message) => message[12 /* type */] == 1 /* EVENT */;\nconst isValueSync = (message) => message[12 /* type */] == 4 /* SYNC */;\nconst isBoundingClientRect = (message) => message[12 /* type */] === 6 /* GET_BOUNDING_CLIENT_RECT */;\nconst isGetStorage = (message) => message[12 /* type */] === 11 /* GET_STORAGE */;\n/**\n * @param nodeContext {NodeContext}\n * @param event {TransferrableEvent}\n */\nfunction readableTransferrableEvent(nodeContext, event) {\n    const value = (item) => {\n        if (typeof item === 'number' || typeof item === 'boolean') {\n            return item !== undefined ? item : null;\n        }\n        return item !== undefined && item !== null ? readableTransferredNode(nodeContext, item) : null;\n    };\n    return {\n        type: event[12 /* type */],\n        bubbles: value(event[25 /* bubbles */]),\n        cancelable: value(event[26 /* cancelable */]),\n        cancelBubble: value(event[27 /* cancelBubble */]),\n        defaultPrevented: value(event[29 /* defaultPrevented */]),\n        eventPhase: value(event[30 /* eventPhase */]),\n        isTrusted: value(event[31 /* isTrusted */]),\n        returnValue: value(event[32 /* returnValue */]),\n        currentTarget: value(event[28 /* currentTarget */]),\n        target: value(event[13 /* target */]),\n        scoped: value(event[34 /* scoped */]),\n        keyCode: value(event[35 /* keyCode */]),\n    };\n}\n/**\n * @param nodeContext {NodeContext}\n * @param value {TransferrableSyncValue}\n */\nfunction readableTransferrableSyncValue(nodeContext, value) {\n    const index = value[7 /* index */];\n    return {\n        target: nodeContext.getNode(index) || index,\n        value: value[21 /* value */],\n    };\n}\n/**\n * @param message\n */\nexport function readableMessageToWorker(nodeContext, message) {\n    if (isEvent(message)) {\n        const event = message[39 /* event */];\n        return {\n            type: 'EVENT',\n            event: readableTransferrableEvent(nodeContext, event),\n        };\n    }\n    else if (isValueSync(message)) {\n        const sync = message[40 /* sync */];\n        return {\n            type: 'SYNC',\n            sync: readableTransferrableSyncValue(nodeContext, sync),\n        };\n    }\n    else if (isBoundingClientRect(message)) {\n        return {\n            type: 'GET_BOUNDING_CLIENT_RECT',\n            target: readableTransferredNode(nodeContext, message[13 /* target */]),\n        };\n    }\n    else if (isGetStorage(message)) {\n        return {\n            type: 'GET_STORAGE',\n            key: message[74 /* storageKey */],\n            location: message[75 /* storageLocation */],\n            value: message[21 /* value */],\n        };\n    }\n    else {\n        return 'Unrecognized MessageToWorker type: ' + message[12 /* type */];\n    }\n}\n//# sourceMappingURL=debugging.js.map","/**\n * Stores objects that have their behavior handled from the main-thread. Each object is associated to a unique ID.\n */\nexport class ObjectContext {\n    objects;\n    constructor() {\n        this.objects = new Map();\n    }\n    store(id, obj) {\n        this.objects.set(id, obj);\n    }\n    get(id) {\n        const obj = this.objects.get(id);\n        if (obj) {\n            return obj;\n        }\n        else {\n            throw new Error('Object with id (' + id + ') does not exist.');\n        }\n    }\n}\n//# sourceMappingURL=object-context.js.map","import { registerPromise } from './commands/function';\n/**\n * An ExportedWorker is returned by the upgradeElement API.\n * For the most part, it delegates to the underlying Worker.\n *\n * It notably removes `postMessage` support and adds `callFunction`.\n */\nexport class ExportedWorker {\n    workerContext_;\n    config;\n    constructor(workerContext, config) {\n        this.workerContext_ = workerContext;\n        this.config = config;\n    }\n    /**\n     * Calls a function in the worker and returns a promise with the result.\n     * @param functionIdentifer\n     * @param functionArguments\n     */\n    callFunction(functionIdentifer, ...functionArguments) {\n        if (!this.config.executorsAllowed.includes(13 /* FUNCTION_CALL */)) {\n            throw new Error(`[worker-dom]: Error calling ${functionIdentifer}. You must enable the FUNCTION_CALL executor within the config.`);\n        }\n        const { promise, index } = registerPromise();\n        const msg = {\n            [12 /* type */]: 12 /* FUNCTION */,\n            [77 /* functionIdentifier */]: functionIdentifer,\n            [78 /* functionArguments */]: JSON.stringify(functionArguments),\n            [7 /* index */]: index,\n        };\n        this.workerContext_.messageToWorker(msg);\n        return promise;\n    }\n    set onerror(handler) {\n        this.workerContext_.worker.onerror = handler;\n    }\n    terminate() {\n        this.workerContext_.worker.terminate();\n    }\n}\n//# sourceMappingURL=exported-worker.js.map","import { MutatorProcessor } from './mutator';\nimport { NodeContext } from './nodes';\nimport { StringContext } from './strings';\nimport { normalizeConfiguration } from './configuration';\nimport { WorkerContext } from './worker';\nimport { ObjectContext } from './object-context';\nimport { ExportedWorker } from './exported-worker';\nconst ALLOWABLE_MESSAGE_TYPES = [3 /* MUTATE */, 2 /* HYDRATE */];\n/**\n * @param baseElement\n * @param authorScriptURL\n * @param workerDOMURL\n * @param callbacks\n * @param sanitizer\n * @param debug\n */\nexport function fetchAndInstall(baseElement, config) {\n    const fetchPromise = Promise.all([\n        // TODO(KB): Fetch Polyfill for IE11.\n        fetch(config.domURL).then((response) => response.text()),\n        fetch(config.authorURL).then((response) => response.text()),\n    ]);\n    return install(fetchPromise, baseElement, config);\n}\n/**\n * @param fetchPromise\n * @param baseElement\n * @param config\n */\nexport function install(fetchPromise, baseElement, config) {\n    const stringContext = new StringContext();\n    const objectContext = new ObjectContext();\n    const nodeContext = new NodeContext(stringContext, baseElement);\n    const normalizedConfig = normalizeConfiguration(config);\n    return fetchPromise.then(([domScriptContent, authorScriptContent]) => {\n        if (domScriptContent && authorScriptContent && config.authorURL) {\n            const workerContext = new WorkerContext(baseElement, nodeContext, domScriptContent, authorScriptContent, normalizedConfig);\n            const mutatorContext = new MutatorProcessor(stringContext, nodeContext, workerContext, normalizedConfig, objectContext);\n            workerContext.worker.onmessage = (message) => {\n                const { data } = message;\n                if (!ALLOWABLE_MESSAGE_TYPES.includes(data[12 /* type */])) {\n                    return;\n                }\n                mutatorContext.mutate(data[54 /* phase */], data[37 /* nodes */], data[41 /* strings */], new Uint16Array(data[36 /* mutations */]));\n                if (config.onReceiveMessage) {\n                    config.onReceiveMessage(message);\n                }\n            };\n            return workerContext.ready().then(() => new ExportedWorker(workerContext, normalizedConfig));\n        }\n        return null;\n    });\n}\n//# sourceMappingURL=install.js.map"],"names":[],"mappings":"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"}